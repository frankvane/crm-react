{
    "sourceFile": "src/api/request.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1746086831483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1746088927765,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,190 +1,190 @@\n-import { MutationCache, QueryCache, QueryClient } from \"@tanstack/react-query\";\r\n-import axios, { AxiosInstance, AxiosResponse } from \"axios\";\r\n-\r\n-import type { AxiosRequestConfig } from \"axios\";\r\n-import createAuthRefreshInterceptor from \"axios-auth-refresh\";\r\n-import { message } from \"antd\";\r\n-import { useAuthStore } from \"@/store/modules/auth\";\r\n-\r\n-// 引入 axios-auth-refresh 库\r\n-\r\n-// 配置全局消息提示\r\n-message.config({\r\n-  maxCount: 1,\r\n-  duration: 3,\r\n-  top: 24,\r\n-});\r\n-\r\n-// 简洁的消息函数\r\n-export const showErrorMessage = (content: string) => message.error(content);\r\n-export const showSuccessMessage = (content: string) => message.success(content);\r\n-\r\n-// 创建axios实例\r\n-const request: AxiosInstance = axios.create({\r\n-  baseURL: import.meta.env.VITE_API_BASE_URL || \"/api\",\r\n-  timeout: 15000,\r\n-  headers: {\r\n-    \"Content-Type\": \"application/json\",\r\n-  },\r\n-});\r\n-\r\n-// 请求拦截器\r\n-request.interceptors.request.use(\r\n-  (config: AxiosRequestConfig) => {\r\n-    const token = useAuthStore.getState().token;\r\n-    if (token) {\r\n-      config.headers = {\r\n-        ...config.headers,\r\n-        Authorization: `Bearer ${token}`,\r\n-      };\r\n-    }\r\n-    return config;\r\n-  },\r\n-  (error) => {\r\n-    return Promise.reject(error);\r\n-  }\r\n-);\r\n-\r\n-// 响应拦截器\r\n-request.interceptors.response.use(\r\n-  (response: AxiosResponse) => {\r\n-    const { data } = response;\r\n-\r\n-    // 这里可以根据后端的响应结构进行调整\r\n-    if (data.code !== 0) {\r\n-      message.error(data.message || \"请求失败\");\r\n-      return Promise.reject(new Error(data.message || \"请求失败\"));\r\n-    }\r\n-\r\n-    return data;\r\n-  },\r\n-  (error) => {\r\n-    if (error.response) {\r\n-      const { status } = error.response;\r\n-      switch (status) {\r\n-        case 401:\r\n-          // 未授权，清除token并跳转到登录页\r\n-          useAuthStore.getState().logout();\r\n-          break;\r\n-        case 403:\r\n-          message.error(\"没有权限访问\");\r\n-          break;\r\n-        case 404:\r\n-          message.error(\"请求的资源不存在\");\r\n-          break;\r\n-        case 500:\r\n-          message.error(\"服务器错误\");\r\n-          break;\r\n-        default:\r\n-          message.error(\"网络错误\");\r\n-      }\r\n-    } else {\r\n-      message.error(\"网络错误\");\r\n-    }\r\n-    return Promise.reject(error);\r\n-  }\r\n-);\r\n-\r\n-// 简化的 Token 刷新逻辑\r\n-const refreshAuthLogic = async (failedRequest: any) => {\r\n-  try {\r\n-    // 模拟刷新 token API 调用\r\n-    // 实际项目中应该调用真正的刷新 API\r\n-    console.log(\"Refreshing token...\");\r\n-    const newToken = \"new-token\";\r\n-\r\n-    // 更新本地存储\r\n-    localStorage.setItem(\"token\", newToken);\r\n-\r\n-    // 更新失败请求的 Authorization 头\r\n-    failedRequest.response.config.headers[\r\n-      \"Authorization\"\r\n-    ] = `Bearer ${newToken}`;\r\n-\r\n-    // 更新默认 headers\r\n-    request.defaults.headers.common[\"Authorization\"] = `Bearer ${newToken}`;\r\n-\r\n-    return Promise.resolve();\r\n-  } catch (error) {\r\n-    localStorage.removeItem(\"token\");\r\n-    // 可以在这里添加重定向逻辑\r\n-    return Promise.reject(error);\r\n-  }\r\n-};\r\n-\r\n-// 注册刷新拦截器\r\n-createAuthRefreshInterceptor(request, refreshAuthLogic, {\r\n-  statusCodes: [401], // 默认就是 401，此处可以省略\r\n-});\r\n-\r\n-// 简化的错误消息获取\r\n-export const getErrorMessage = (error: unknown): string => {\r\n-  if (!axios.isAxiosError(error)) return \"未知错误\";\r\n-\r\n-  // 使用更简洁的方式处理错误消息映射\r\n-  return (\r\n-    {\r\n-      400: \"请求错误\",\r\n-      401: \"未授权，请登录\",\r\n-      403: \"拒绝访问\",\r\n-      404: \"请求地址出错\",\r\n-      408: \"请求超时\",\r\n-      500: \"服务器内部错误\",\r\n-      502: \"网关错误\",\r\n-      503: \"服务不可用\",\r\n-      504: \"网关超时\",\r\n-    }[error.response?.status as number] || \"网络请求失败\"\r\n-  );\r\n-};\r\n-\r\n-// 创建请求函数\r\n-export const createRequest = <T>(\r\n-  method: string,\r\n-  url: string,\r\n-  config?: Omit<AxiosRequestConfig, \"method\" | \"url\">\r\n-) => {\r\n-  // 返回一个符合 React Query 查询函数格式的函数\r\n-  // 注意：查询函数接收一个包含 signal 的对象\r\n-  return async ({ signal }: { signal?: AbortSignal } = {}): Promise<T> => {\r\n-    const response = await request.request<T>({\r\n-      method,\r\n-      url,\r\n-      ...config,\r\n-      // 将 AbortSignal 传递给 axios 请求\r\n-      signal,\r\n-    });\r\n-    return response.data;\r\n-  };\r\n-};\r\n-\r\n-// 创建查询客户端\r\n-export const queryClient = new QueryClient({\r\n-  defaultOptions: {\r\n-    queries: {\r\n-      refetchOnWindowFocus: false,\r\n-      retry: 1,\r\n-      staleTime: 5 * 60 * 1000, // 5 分钟\r\n-    },\r\n-    mutations: {\r\n-      onError: (error: unknown) => {\r\n-        console.error(\"Mutation error:\", error);\r\n-      },\r\n-    },\r\n-  },\r\n-  // 集中错误处理\r\n-  queryCache: new QueryCache({\r\n-    onError: (error) => showErrorMessage(getErrorMessage(error)),\r\n-  }),\r\n-  mutationCache: new MutationCache({\r\n-    onError: (error) => showErrorMessage(getErrorMessage(error)),\r\n-  }),\r\n-});\r\n-\r\n-// 取消所有请求\r\n-export const cancelAllQueries = async () => {\r\n-  return queryClient.cancelQueries({\r\n-    type: \"all\",\r\n-  });\r\n-};\r\n-\r\n-export default request;\r\n+import { MutationCache, QueryCache, QueryClient } from \"@tanstack/react-query\";\n+import axios, { AxiosInstance, AxiosResponse } from \"axios\";\n+\n+import type { AxiosRequestConfig } from \"axios\";\n+import createAuthRefreshInterceptor from \"axios-auth-refresh\";\n+import { message } from \"antd\";\n+import { useAuthStore } from \"@/store/modules/auth\";\n+\n+// 引入 axios-auth-refresh 库\n+\n+// 配置全局消息提示\n+message.config({\n+  maxCount: 1,\n+  duration: 3,\n+  top: 24,\n+});\n+\n+// 简洁的消息函数\n+export const showErrorMessage = (content: string) => message.error(content);\n+export const showSuccessMessage = (content: string) => message.success(content);\n+\n+// 创建axios实例\n+const request: AxiosInstance = axios.create({\n+  baseURL: import.meta.env.VITE_API_BASE_URL || \"/api\",\n+  timeout: 15000,\n+  headers: {\n+    \"Content-Type\": \"application/json\",\n+  },\n+});\n+\n+// 请求拦截器\n+request.interceptors.request.use(\n+  (config: AxiosRequestConfig) => {\n+    const token = useAuthStore.getState().token;\n+    if (token) {\n+      config.headers = {\n+        ...config.headers,\n+        Authorization: `Bearer ${token}`,\n+      };\n+    }\n+    return config;\n+  },\n+  (error) => {\n+    return Promise.reject(error);\n+  }\n+);\n+\n+// 响应拦截器\n+request.interceptors.response.use(\n+  (response: AxiosResponse) => {\n+    const { data } = response;\n+\n+    // 这里可以根据后端的响应结构进行调整\n+    if (data.code !== 0) {\n+      message.error(data.message || \"请求失败\");\n+      return Promise.reject(new Error(data.message || \"请求失败\"));\n+    }\n+\n+    return data;\n+  },\n+  (error) => {\n+    if (error.response) {\n+      const { status } = error.response;\n+      switch (status) {\n+        case 401:\n+          // 未授权，清除token并跳转到登录页\n+          useAuthStore.getState().logout();\n+          break;\n+        case 403:\n+          message.error(\"没有权限访问\");\n+          break;\n+        case 404:\n+          message.error(\"请求的资源不存在\");\n+          break;\n+        case 500:\n+          message.error(\"服务器错误\");\n+          break;\n+        default:\n+          message.error(\"网络错误\");\n+      }\n+    } else {\n+      message.error(\"网络错误\");\n+    }\n+    return Promise.reject(error);\n+  }\n+);\n+\n+// 简化的 Token 刷新逻辑\n+const refreshAuthLogic = async (failedRequest: any) => {\n+  try {\n+    // 模拟刷新 token API 调用\n+    // 实际项目中应该调用真正的刷新 API\n+    console.log(\"Refreshing token...\");\n+    const newToken = \"new-token\";\n+\n+    // 更新本地存储\n+    localStorage.setItem(\"token\", newToken);\n+\n+    // 更新失败请求的 Authorization 头\n+    failedRequest.response.config.headers[\n+      \"Authorization\"\n+    ] = `Bearer ${newToken}`;\n+\n+    // 更新默认 headers\n+    request.defaults.headers.common[\"Authorization\"] = `Bearer ${newToken}`;\n+\n+    return Promise.resolve();\n+  } catch (error) {\n+    localStorage.removeItem(\"token\");\n+    // 可以在这里添加重定向逻辑\n+    return Promise.reject(error);\n+  }\n+};\n+\n+// 注册刷新拦截器\n+createAuthRefreshInterceptor(request, refreshAuthLogic, {\n+  statusCodes: [401], // 默认就是 401，此处可以省略\n+});\n+\n+// 简化的错误消息获取\n+export const getErrorMessage = (error: unknown): string => {\n+  if (!axios.isAxiosError(error)) return \"未知错误\";\n+\n+  // 使用更简洁的方式处理错误消息映射\n+  return (\n+    {\n+      400: \"请求错误\",\n+      401: \"未授权，请登录\",\n+      403: \"拒绝访问\",\n+      404: \"请求地址出错\",\n+      408: \"请求超时\",\n+      500: \"服务器内部错误\",\n+      502: \"网关错误\",\n+      503: \"服务不可用\",\n+      504: \"网关超时\",\n+    }[error.response?.status as number] || \"网络请求失败\"\n+  );\n+};\n+\n+// 创建请求函数\n+export const createRequest = <T>(\n+  method: string,\n+  url: string,\n+  config?: Omit<AxiosRequestConfig, \"method\" | \"url\">\n+) => {\n+  // 返回一个符合 React Query 查询函数格式的函数\n+  // 注意：查询函数接收一个包含 signal 的对象\n+  return async ({ signal }: { signal?: AbortSignal } = {}): Promise<T> => {\n+    const response = await request.request<T>({\n+      method,\n+      url,\n+      ...config,\n+      // 将 AbortSignal 传递给 axios 请求\n+      signal,\n+    });\n+    return response.data;\n+  };\n+};\n+\n+// 创建查询客户端\n+export const queryClient = new QueryClient({\n+  defaultOptions: {\n+    queries: {\n+      refetchOnWindowFocus: false,\n+      retry: 1,\n+      staleTime: 5 * 60 * 1000, // 5 分钟\n+    },\n+    mutations: {\n+      onError: (error: unknown) => {\n+        console.error(\"Mutation error:\", error);\n+      },\n+    },\n+  },\n+  // 集中错误处理\n+  queryCache: new QueryCache({\n+    onError: (error) => showErrorMessage(getErrorMessage(error)),\n+  }),\n+  mutationCache: new MutationCache({\n+    onError: (error) => showErrorMessage(getErrorMessage(error)),\n+  }),\n+});\n+\n+// 取消所有请求\n+export const cancelAllQueries = async () => {\n+  return queryClient.cancelQueries({\n+    type: \"all\",\n+  });\n+};\n+\n+export default request;\n"
                },
                {
                    "date": 1746089772233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,14 +50,15 @@\n   (response: AxiosResponse) => {\n     const { data } = response;\n \n     // 这里可以根据后端的响应结构进行调整\n-    if (data.code !== 0) {\n+    if (data.code === 200) {\n+      return data;\n+    } else {\n+      const error = new Error(data.message || \"请求失败\");\n       message.error(data.message || \"请求失败\");\n-      return Promise.reject(new Error(data.message || \"请求失败\"));\n+      return Promise.reject(error);\n     }\n-\n-    return data;\n   },\n   (error) => {\n     if (error.response) {\n       const { status } = error.response;\n"
                },
                {
                    "date": 1746089790114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,11 @@\n   }\n );\n \n // 简化的 Token 刷新逻辑\n-const refreshAuthLogic = async (failedRequest: any) => {\n+const refreshAuthLogic = async (failedRequest: {\n+  response: { config: { headers: Record<string, string> } };\n+}): Promise<void> => {\n   try {\n     // 模拟刷新 token API 调用\n     // 实际项目中应该调用真正的刷新 API\n     console.log(\"Refreshing token...\");\n"
                },
                {
                    "date": 1746089814474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,10 @@\n import { MutationCache, QueryCache, QueryClient } from \"@tanstack/react-query\";\n-import axios, { AxiosInstance, AxiosResponse } from \"axios\";\n+import axios, {\n+  AxiosInstance,\n+  AxiosResponse,\n+  InternalAxiosRequestConfig,\n+} from \"axios\";\n \n import type { AxiosRequestConfig } from \"axios\";\n import createAuthRefreshInterceptor from \"axios-auth-refresh\";\n import { message } from \"antd\";\n@@ -29,15 +33,12 @@\n });\n \n // 请求拦截器\n request.interceptors.request.use(\n-  (config: AxiosRequestConfig) => {\n+  (config: InternalAxiosRequestConfig) => {\n     const token = useAuthStore.getState().token;\n     if (token) {\n-      config.headers = {\n-        ...config.headers,\n-        Authorization: `Bearer ${token}`,\n-      };\n+      config.headers.set(\"Authorization\", `Bearer ${token}`);\n     }\n     return config;\n   },\n   (error) => {\n"
                },
                {
                    "date": 1746089908724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,194 +0,0 @@\n-import { MutationCache, QueryCache, QueryClient } from \"@tanstack/react-query\";\n-import axios, {\n-  AxiosInstance,\n-  AxiosResponse,\n-  InternalAxiosRequestConfig,\n-} from \"axios\";\n-\n-import type { AxiosRequestConfig } from \"axios\";\n-import createAuthRefreshInterceptor from \"axios-auth-refresh\";\n-import { message } from \"antd\";\n-import { useAuthStore } from \"@/store/modules/auth\";\n-\n-// 引入 axios-auth-refresh 库\n-\n-// 配置全局消息提示\n-message.config({\n-  maxCount: 1,\n-  duration: 3,\n-  top: 24,\n-});\n-\n-// 简洁的消息函数\n-export const showErrorMessage = (content: string) => message.error(content);\n-export const showSuccessMessage = (content: string) => message.success(content);\n-\n-// 创建axios实例\n-const request: AxiosInstance = axios.create({\n-  baseURL: import.meta.env.VITE_API_BASE_URL || \"/api\",\n-  timeout: 15000,\n-  headers: {\n-    \"Content-Type\": \"application/json\",\n-  },\n-});\n-\n-// 请求拦截器\n-request.interceptors.request.use(\n-  (config: InternalAxiosRequestConfig) => {\n-    const token = useAuthStore.getState().token;\n-    if (token) {\n-      config.headers.set(\"Authorization\", `Bearer ${token}`);\n-    }\n-    return config;\n-  },\n-  (error) => {\n-    return Promise.reject(error);\n-  }\n-);\n-\n-// 响应拦截器\n-request.interceptors.response.use(\n-  (response: AxiosResponse) => {\n-    const { data } = response;\n-\n-    // 这里可以根据后端的响应结构进行调整\n-    if (data.code === 200) {\n-      return data;\n-    } else {\n-      const error = new Error(data.message || \"请求失败\");\n-      message.error(data.message || \"请求失败\");\n-      return Promise.reject(error);\n-    }\n-  },\n-  (error) => {\n-    if (error.response) {\n-      const { status } = error.response;\n-      switch (status) {\n-        case 401:\n-          // 未授权，清除token并跳转到登录页\n-          useAuthStore.getState().logout();\n-          break;\n-        case 403:\n-          message.error(\"没有权限访问\");\n-          break;\n-        case 404:\n-          message.error(\"请求的资源不存在\");\n-          break;\n-        case 500:\n-          message.error(\"服务器错误\");\n-          break;\n-        default:\n-          message.error(\"网络错误\");\n-      }\n-    } else {\n-      message.error(\"网络错误\");\n-    }\n-    return Promise.reject(error);\n-  }\n-);\n-\n-// 简化的 Token 刷新逻辑\n-const refreshAuthLogic = async (failedRequest: {\n-  response: { config: { headers: Record<string, string> } };\n-}): Promise<void> => {\n-  try {\n-    // 模拟刷新 token API 调用\n-    // 实际项目中应该调用真正的刷新 API\n-    console.log(\"Refreshing token...\");\n-    const newToken = \"new-token\";\n-\n-    // 更新本地存储\n-    localStorage.setItem(\"token\", newToken);\n-\n-    // 更新失败请求的 Authorization 头\n-    failedRequest.response.config.headers[\n-      \"Authorization\"\n-    ] = `Bearer ${newToken}`;\n-\n-    // 更新默认 headers\n-    request.defaults.headers.common[\"Authorization\"] = `Bearer ${newToken}`;\n-\n-    return Promise.resolve();\n-  } catch (error) {\n-    localStorage.removeItem(\"token\");\n-    // 可以在这里添加重定向逻辑\n-    return Promise.reject(error);\n-  }\n-};\n-\n-// 注册刷新拦截器\n-createAuthRefreshInterceptor(request, refreshAuthLogic, {\n-  statusCodes: [401], // 默认就是 401，此处可以省略\n-});\n-\n-// 简化的错误消息获取\n-export const getErrorMessage = (error: unknown): string => {\n-  if (!axios.isAxiosError(error)) return \"未知错误\";\n-\n-  // 使用更简洁的方式处理错误消息映射\n-  return (\n-    {\n-      400: \"请求错误\",\n-      401: \"未授权，请登录\",\n-      403: \"拒绝访问\",\n-      404: \"请求地址出错\",\n-      408: \"请求超时\",\n-      500: \"服务器内部错误\",\n-      502: \"网关错误\",\n-      503: \"服务不可用\",\n-      504: \"网关超时\",\n-    }[error.response?.status as number] || \"网络请求失败\"\n-  );\n-};\n-\n-// 创建请求函数\n-export const createRequest = <T>(\n-  method: string,\n-  url: string,\n-  config?: Omit<AxiosRequestConfig, \"method\" | \"url\">\n-) => {\n-  // 返回一个符合 React Query 查询函数格式的函数\n-  // 注意：查询函数接收一个包含 signal 的对象\n-  return async ({ signal }: { signal?: AbortSignal } = {}): Promise<T> => {\n-    const response = await request.request<T>({\n-      method,\n-      url,\n-      ...config,\n-      // 将 AbortSignal 传递给 axios 请求\n-      signal,\n-    });\n-    return response.data;\n-  };\n-};\n-\n-// 创建查询客户端\n-export const queryClient = new QueryClient({\n-  defaultOptions: {\n-    queries: {\n-      refetchOnWindowFocus: false,\n-      retry: 1,\n-      staleTime: 5 * 60 * 1000, // 5 分钟\n-    },\n-    mutations: {\n-      onError: (error: unknown) => {\n-        console.error(\"Mutation error:\", error);\n-      },\n-    },\n-  },\n-  // 集中错误处理\n-  queryCache: new QueryCache({\n-    onError: (error) => showErrorMessage(getErrorMessage(error)),\n-  }),\n-  mutationCache: new MutationCache({\n-    onError: (error) => showErrorMessage(getErrorMessage(error)),\n-  }),\n-});\n-\n-// 取消所有请求\n-export const cancelAllQueries = async () => {\n-  return queryClient.cancelQueries({\n-    type: \"all\",\n-  });\n-};\n-\n-export default request;\n\\ No newline at end of file\n"
                }
            ],
            "date": 1746086831483,
            "name": "Commit-0",
            "content": "import { MutationCache, QueryCache, QueryClient } from \"@tanstack/react-query\";\r\nimport axios, { AxiosInstance, AxiosResponse } from \"axios\";\r\n\r\nimport type { AxiosRequestConfig } from \"axios\";\r\nimport createAuthRefreshInterceptor from \"axios-auth-refresh\";\r\nimport { message } from \"antd\";\r\nimport { useAuthStore } from \"@/store/modules/auth\";\r\n\r\n// 引入 axios-auth-refresh 库\r\n\r\n// 配置全局消息提示\r\nmessage.config({\r\n  maxCount: 1,\r\n  duration: 3,\r\n  top: 24,\r\n});\r\n\r\n// 简洁的消息函数\r\nexport const showErrorMessage = (content: string) => message.error(content);\r\nexport const showSuccessMessage = (content: string) => message.success(content);\r\n\r\n// 创建axios实例\r\nconst request: AxiosInstance = axios.create({\r\n  baseURL: import.meta.env.VITE_API_BASE_URL || \"/api\",\r\n  timeout: 15000,\r\n  headers: {\r\n    \"Content-Type\": \"application/json\",\r\n  },\r\n});\r\n\r\n// 请求拦截器\r\nrequest.interceptors.request.use(\r\n  (config: AxiosRequestConfig) => {\r\n    const token = useAuthStore.getState().token;\r\n    if (token) {\r\n      config.headers = {\r\n        ...config.headers,\r\n        Authorization: `Bearer ${token}`,\r\n      };\r\n    }\r\n    return config;\r\n  },\r\n  (error) => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// 响应拦截器\r\nrequest.interceptors.response.use(\r\n  (response: AxiosResponse) => {\r\n    const { data } = response;\r\n\r\n    // 这里可以根据后端的响应结构进行调整\r\n    if (data.code !== 0) {\r\n      message.error(data.message || \"请求失败\");\r\n      return Promise.reject(new Error(data.message || \"请求失败\"));\r\n    }\r\n\r\n    return data;\r\n  },\r\n  (error) => {\r\n    if (error.response) {\r\n      const { status } = error.response;\r\n      switch (status) {\r\n        case 401:\r\n          // 未授权，清除token并跳转到登录页\r\n          useAuthStore.getState().logout();\r\n          break;\r\n        case 403:\r\n          message.error(\"没有权限访问\");\r\n          break;\r\n        case 404:\r\n          message.error(\"请求的资源不存在\");\r\n          break;\r\n        case 500:\r\n          message.error(\"服务器错误\");\r\n          break;\r\n        default:\r\n          message.error(\"网络错误\");\r\n      }\r\n    } else {\r\n      message.error(\"网络错误\");\r\n    }\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// 简化的 Token 刷新逻辑\r\nconst refreshAuthLogic = async (failedRequest: any) => {\r\n  try {\r\n    // 模拟刷新 token API 调用\r\n    // 实际项目中应该调用真正的刷新 API\r\n    console.log(\"Refreshing token...\");\r\n    const newToken = \"new-token\";\r\n\r\n    // 更新本地存储\r\n    localStorage.setItem(\"token\", newToken);\r\n\r\n    // 更新失败请求的 Authorization 头\r\n    failedRequest.response.config.headers[\r\n      \"Authorization\"\r\n    ] = `Bearer ${newToken}`;\r\n\r\n    // 更新默认 headers\r\n    request.defaults.headers.common[\"Authorization\"] = `Bearer ${newToken}`;\r\n\r\n    return Promise.resolve();\r\n  } catch (error) {\r\n    localStorage.removeItem(\"token\");\r\n    // 可以在这里添加重定向逻辑\r\n    return Promise.reject(error);\r\n  }\r\n};\r\n\r\n// 注册刷新拦截器\r\ncreateAuthRefreshInterceptor(request, refreshAuthLogic, {\r\n  statusCodes: [401], // 默认就是 401，此处可以省略\r\n});\r\n\r\n// 简化的错误消息获取\r\nexport const getErrorMessage = (error: unknown): string => {\r\n  if (!axios.isAxiosError(error)) return \"未知错误\";\r\n\r\n  // 使用更简洁的方式处理错误消息映射\r\n  return (\r\n    {\r\n      400: \"请求错误\",\r\n      401: \"未授权，请登录\",\r\n      403: \"拒绝访问\",\r\n      404: \"请求地址出错\",\r\n      408: \"请求超时\",\r\n      500: \"服务器内部错误\",\r\n      502: \"网关错误\",\r\n      503: \"服务不可用\",\r\n      504: \"网关超时\",\r\n    }[error.response?.status as number] || \"网络请求失败\"\r\n  );\r\n};\r\n\r\n// 创建请求函数\r\nexport const createRequest = <T>(\r\n  method: string,\r\n  url: string,\r\n  config?: Omit<AxiosRequestConfig, \"method\" | \"url\">\r\n) => {\r\n  // 返回一个符合 React Query 查询函数格式的函数\r\n  // 注意：查询函数接收一个包含 signal 的对象\r\n  return async ({ signal }: { signal?: AbortSignal } = {}): Promise<T> => {\r\n    const response = await request.request<T>({\r\n      method,\r\n      url,\r\n      ...config,\r\n      // 将 AbortSignal 传递给 axios 请求\r\n      signal,\r\n    });\r\n    return response.data;\r\n  };\r\n};\r\n\r\n// 创建查询客户端\r\nexport const queryClient = new QueryClient({\r\n  defaultOptions: {\r\n    queries: {\r\n      refetchOnWindowFocus: false,\r\n      retry: 1,\r\n      staleTime: 5 * 60 * 1000, // 5 分钟\r\n    },\r\n    mutations: {\r\n      onError: (error: unknown) => {\r\n        console.error(\"Mutation error:\", error);\r\n      },\r\n    },\r\n  },\r\n  // 集中错误处理\r\n  queryCache: new QueryCache({\r\n    onError: (error) => showErrorMessage(getErrorMessage(error)),\r\n  }),\r\n  mutationCache: new MutationCache({\r\n    onError: (error) => showErrorMessage(getErrorMessage(error)),\r\n  }),\r\n});\r\n\r\n// 取消所有请求\r\nexport const cancelAllQueries = async () => {\r\n  return queryClient.cancelQueries({\r\n    type: \"all\",\r\n  });\r\n};\r\n\r\nexport default request;\r\n"
        }
    ]
}